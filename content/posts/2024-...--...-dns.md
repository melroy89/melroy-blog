---
title: Domain Name System (DNS)
author: Melroy van den Berg
type: post
date: 2024-01-01T00:00:00+01:00
draft: true
url: /?p=1354
categories:
  - Intermediate
  - Windows OS
---

Root servers?
https://www.cloudflare.com/learning/dns/glossary/dns-root-server/

ZOnes.. etc.

See also: https://en.wikipedia.org/wiki/Root_name_server#Root_server_addresses

DNS record syntax:

https://www.ionos.com/digitalguide/hosting/technical-matters/dns-records/

UNbound DNS: https://calomel.org/unbound_dns.html

NSD DNS: https://calomel.org/nsd_dns.html . See also: https://lowendbox.com/blog/setup-a-dns-nameserver-using-nsd/

https://starbeamrainbowlabs.com/blog/article.php?article=posts/514-dns-nsd.html



---

# Setup NSD & Unbound DNS servers

I'm using Ubuntu Server 24.04 is this example.

## NSD

I will start with setting-up NSD (Name Server Daemon), which is an authoritative DNS server. Let's install NSD:

```sh
sudo apt install nsd
```

The default port NSD will try to use is port `53`. However, port 53 is already reserved by either systemd-resolved or in our case when we later will install Unbound recursive DNS server. We change the port by editing `/etc/nsd/nsd.conf` more info can be found by running `man nsd.conf`:

```ini
server:
  # Change default port
  port: 5353

  # log only to syslog.
  log-only-syslog: yes
```

Next, I want to make some additional small changes. I want to start two sub-processes in order to use two of my cores (if needed).  
I also want to explicitly set the username to change to `nsd` for security reasons. Now `/etc/nsd/nsd.conf` looks like this:

```ini
server:
  # Change default port
  port: 5353
  server-count: 2
  username: nsd
  # log only to syslog.
  log-only-syslog: yes
```

---

### PID file

If you are also like to use a PID (process ID) files? Which can be useful when used together with Monit for monitoring services. Then follow this section, otherwise skip this optional section.


Add `pidfile: /var/run/nsd/nsd.pid` to the `/etc/nsd/nsd.conf` config:

```ini
server:
  ...
  pidfile: /var/run/nsd/nsd.pid
```

Edit the `/usr/lib/systemd/system/nsd.service` file and remove `-P ""`:

```diff
-ExecStart=/usr/sbin/nsd -d -P ""
+ExecStart=/usr/sbin/nsd -d
```

Otherwise a PID file will still not be written to disk ðŸ˜–.

Now run since we changed a service file:

```sh
sudo systemctl daemon-reload
```

This is the end of the PID section.

---

### Remote control

Why remote control..? TODO: Explain.

Since I have IPv6 disabled on my server via sysctl, it fail to start because NSD by default try to enable remote control on both IPV4 and IPV6 interfaces (apparently, only when using Ubuntu).

Running a remote-control interface is fine, but again since I only use IPV4, I change the config to listen on only 127.0.0.1 (I also set `control-enable: yes` explicitly just to be sure):

```ini
server:
  ... # See above

# Remote control section
remote-control:
  control-enable: yes
  # Only bind on IPv4
  control-interface: 127.0.0.1
```

## Zones

Now we could try to setup a simple zone for let's say our *.home domains internally. Of course NSD can be used for real domains as well, giving you full control over all DNS records. But let's start small here.

We will edit the same `/etc/nsd/nsd.conf` file and add a new zone:

```ini
zone:
    name: home
    zonefile: "home"
```

As you notice we declared a `zonefile`, but we didn't create one yet. So let's do that now:

Create a new file at: `/etc/nsd/home`, with the content:

```sh
; /usr/local/etc/nsd/home
$ORIGIN home.       ; 'default' domain as FQDN for this zone
$TTL 7200           ; default time-to-live for this zone

; The at sign below is just a quick way of referring to our origin, in our case home.
@ IN SOA ns1.home. melroy.melroy.org. (
        2024102401  ;Serial number (aka version, often use date)
        14400       ;Refresh
        3600        ;Retry
        1209600     ;Expire
        3600        ;Negative response caching TTL
)

; The nameserver that are authoritative for this zone.
                NS      ns1.home.

; A records are for IPv4  
firewall        A       192.168.1.1
server          A       192.168.1.42
melroy          A       192.168.1.116
htpc            A       192.168.1.110
# Here is the glue record:
ns1             A       192.168.1.42
```

Reminder that the origin domain ends with a dot (`home.`). And the record that don't end with a dot, like `melroy` or `server` will automatically be appended with the origin domain, so it's the same as providing `home.home.` and `server.home.`.

`@`-sign is just a shortcut for the origin domain.

The `IN` record class is optional. If the record class (so in this case `IN`) is omitted the resulting value will be set from the preceding record (which the SOA record, which is also `IN`). 

Now you can try to restart NSD:

```sh
sudo systemctl restart nsd.service
```

### Reverse zone

What abotu setting up a reverse zone?




TODO: Should we use `IN` or not in the zone file? Is it optional?

TODO: Should we use `melroy.home.` or just `melroy`?

## Unbound

What is unbound? blalba..

### Systemd-resolved

Since we try to use Unbound recursive DNS server on port 53, we need to make some changes to the systemd-resolved service.

Create a directory `resolved.conf.d` under `/etc/systemd`:

```sh
sudo mkdir -p /etc/systemd/resolved.conf.d/
```

Introduce a new file: `sudo nano /etc/systemd/resolved.conf.d/unbound-changes.conf` with the content:

```ini
[Resolve]
DNS=127.0.0.1
DNSSEC=yes
DNSStubListener=no
```

Setting `DNSStubListener=no` should disable systemd resolved to use port 53, while still allowing us to use DHCP, since DHCP is taken care by systemd resolved. Next, we also want to enable `DNSEC` and explicitly set the DNS server to our localhost IP address (127.0.0.1).

Now we can restart systemd resolved:

```sh
systemctl restart systemd-resolved
```

### Configure Unbound

I made some changes to the `/etc/unbound/unbound.conf`.

Only bind to IPv4, serve expired DNS records if not responding within 500ms (but max. 1 day old).

Increase Unbound caches, outgoing ranges and queries per thread for better performance. 

Enable access control on the LAN network `192.168.0.0/16` is a pretty wide range from: `192.168.0.1 - 192.168.255.254`.

And finally `do-not-query-localhost` to `no` to _allow_ local queries. This is important, since we want to query NSD locally.

```sh
server:
  # Only bind on IPv4
  interface: 0.0.0.0
  # Also bind on IPv6 (if you want to)
  # interface: ::0

  # Serve stale data
  serve-expired: yes
  serve-expired-ttl: 86400           # one day, in seconds
  serve-expired-client-timeout: 500  # 500ms

  # Increase caches for better performance
  msg-cache-slabs: 4
  rrset-cache-slabs: 4
  infra-cache-slabs: 4
  key-cache-slabs: 4

  rrset-cache-size: 100m
  msg-cache-size: 50m

  outgoing-range: 200
  num-queries-per-thread: 100

  # Allow access control on LAN network
  access-control: 192.168.0.0/16 allow

  # Enable localhost to be queried
  do-not-query-localhost: no
```

Next, to pass requests from Unbound towards NSD. We need to specify `local-zone` and `domain-insecure` as well as a new  `stub-zone` in Unbound. So now the `/etc/unbound/unbound.conf` file looks like this:

```sh
server:
  # Same as above...
  # [...]
  
  # Now we also add:
  local-zone: "home" nodefault
  domain-insecure: "home"

# And define a stub-zone
stub-zone:
  name: "home."
  stub-addr: 127.0.0.1@5353
```

Alternatively, create new conf files in the `/etc/unbound/unbound.conf.d` directory instead of editing `/etc/unbound/unbound.conf` directly.


Restart Unbound:

```sh
sudo systemctl restart unbound
```

## Testing

Test a domain name using the dig BIND tool (no worries works also fine WITHOUT using BINDðŸ˜ƒ):

```sh
dig google.com
```

Expected output:

```sh
; <<>> DiG 9.18.28-0ubuntu0.24.04.1-Ubuntu <<>> google.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 40910
;; flags: qr rd ra; QUERY: 1, ANSWER: 6, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 1232
;; QUESTION SECTION:
;google.com.			IN	A

;; ANSWER SECTION:
google.com.		240	IN	A	142.250.102.101
google.com.		240	IN	A	142.250.102.138
google.com.		240	IN	A	142.250.102.100
google.com.		240	IN	A	142.250.102.139
google.com.		240	IN	A	142.250.102.102
google.com.		240	IN	A	142.250.102.113

;; Query time: 0 msec
;; SERVER: 127.0.0.1#53(127.0.0.1) (UDP)
;; WHEN: Wed Oct 23 22:39:41 CEST 2024
;; MSG SIZE  rcvd: 135
```

That looks good, we got a response without any errors. The line `SERVER: 127.0.0.1#53(127.0.0.1) (UDP)` shows us that indeed the local DNS server was requested here.

Using another DNS server (eg. `8.8.8.8`, which is Google DNS) is also possible via:

```sh
dig yahoo.com @8.8.8.8
```

You can also query NSD locally directly via, instead of Unbound:

```sh
dig melroy.home. -p 5353
```

If something went wrong or you would stop the Unbound service on purpose, you will get the following error message at the top:

```sh
;; communications error to 127.0.0.1#53: connection refused
```

By default the `dig` command will not use the `/etc/resolv.conf` to search in the search domain. So if you want `dig` to to that use the `+search` option:

```sh
dig +search melroy-pc
```

Depending on what the search domain is to, dig will now try to search for a DNS record from your name server (most likely your router), something like: `melroy-pc.fritz.box.`. Since the router most likely have DHCP enabled, and knows all the hostnames within the LAN network.

---

Experiment.

Query root level server for `.com` TLD just for fun:

```sh
dig com. @a.root-servers.net.
```

What about querying name servers of Google?

```sh
dig ns google.com
```

The additional section (`ADDITIONAL SECTION:`) actually shows the glue records of the name servers. Glue records provide A (or AAAA) DNS records with the IP address of the name server(s). So for the Google example `ns3.google.com.` will have both an A record and AAAA record, respeccialy set to: `216.239.36.10` and `2001:4860:4802:36::a`.THe usecase for glue records is when you don't know the IP address behind the the name server, but the domain name is the same as the name server root-name. It would otherwise cause a vicious circle, without a glue record you will be unable to retrieve the IP address behind the name server. Since in order to know the domain you will need the A record from the domain, but for that you will need to know the name server of that domain, etc. etc.

Also fun, reverse DNS. You can also use `dig` to execute a reverse DNS look-up by using the `-x` parameter, be sure to now use an IP address as parameter:

```sh
dig -x 8.8.8.8
```

The answer should be: `dns.google.` using a PTR (Pointer) DNS record.

Same command can be executed on your `home.` name, let's use `melroy.home.` as an example, so let's see again what the IP was?

```sh
dig melroy.home.
```

In my case I see an A record with `192.168.1.102`, now use this IP to do a reverse DNS look-up (if you have configured a reverse zone):

```sh
dig -x 192.168.1.102
```

The answer section from the `dig` output gives successfully `melroy.home.` back again:

```sh
;; ANSWER SECTION:
102.1.168.192.in-addr.arpa. 7073 IN	PTR	melroy.home.
```

Well done!